---
title: "Displaying Interactive Graph \U0001F6A7"
published: true
tags: d3.js graph jekyll tags yduf in-progress
toc: true
---
> Efficient and usable graph display with 1'000 Nodes. A story about [tags](/tags) visualisation.

<div style="overflow: auto; width: 100%; max-height: 400px;">
  <canvas width="400" height="400"></canvas>
</div>

## Context

This my [Bookmarks / blog](/about), where I organize things. Historically I was relying only on post title to search content back, then I used the most simplest form of [jekyll tags](({% post_url 2017-10-26-jekyll-tag-cloud %})) (without using any plugins) so it can still be hosted on github.

Here I am exploring how/if I can make sense of all the tags accumulated all these years, and see the relationship between them. At least that how it started.

## [d3-force](https://d3js.org/d3-force)

This d3 module implements an auto-layout model for displaying complex graph. It's what I choose to use as a starter for the tag graph (didn't consider other tool).

[ChatGPT](https://chatgpt.com/share/67d4209c-94f0-800d-9cb2-b38c22a052e7) was able to quicly write down a working solution, which I manage to fit with my jekyll constraint.

### Some notes, on how this work.

d3-force([^1]) provide the simulation layout that apply the force on nodes([^2]). But the user is still responsible to display the elements, so we have flexibility to hide or show node as well as in which order or style we display them.

**Nodes** is an array of object, they could be _DOM_ object (from _svg_) or anything.  
The d3-force simulation will add property for it's own usage ( like (x,y), (vx,vy), (fx,fy). If choosing svg rendering is coming free, otherwise if using canvas this has to be done explicitly.

The Z-order has to be controlled explicitly since it's not part of simulation itself.
Using [collide-force](https://d3js.org/d3-force/collide) will treat node as circus and avoir overlapping.

Force applied on a given node can be directly push trough simulation [by setting (fx,fy)](https://observablehq.com/@d3/collision-detection/2) on that node - **to be clarified**.
Custom forces [can be applied](https://observablehq.com/@ben-tanen/a-tutorial-to-using-d3-force-from-someone-who-just-learned-ho), to obtain [various results](https://observablehq.com/collection/@d3/d3-force).

**Edges** is also an array, that will be involved in [link force](https://d3js.org/d3-force/link), that will push nodes together or appart depending on the value.

Links rely on _id_ properties of _node_ object to identify how nodes interacts in the simulation.

[^1]: [Force-directed graph component](https://observablehq.com/@d3/force-directed-graph-component)
[^2]: [Disjoint force-directed graph](https://observablehq.com/@d3/disjoint-force-directed-graph/2)

[^3]: [Interactive & Dynamic Force-Directed Graphs with D3](https://medium.com/ninjaconcept/interactive-dynamic-force-directed-graphs-with-d3-da720c6d7811) - A guided tour through D3 version 4.0 force simulations with dynamic data and user interaction


[^4]: [d3-force-layout](https://github.com/xdatavisualteam/d3-force-layout) - Force-directed graph layout using velocity Verlet integration.

## Faster Display

Because of the number of nodes (~1'000) and dense relation between them (which was a surpise), the tool has a hardtime making things stand out.

So additionnal work is needed
- to make the page more responsive
- to make it more usable

This is what we explore below.

### The [tags](/tags) page

Is quite big (3.25MB), it contains
- the html text of tags
- the list of node (tags) and their relation (link between tag) in javascript form.

All generated by jekyll liquid templating.
As the information is duplicated several time, the size could probably reduced a lot:
- node/tag information is contains in the dom, and could be derived from there.
- links can be stored in js and injected in dom if we want to (see _related tag_ unfold field).

### Performance

I started using _svg_ as any example suggest, but [ChatGPT](https://chatgpt.com/share/67d6c69e-3bf0-800d-bbb6-28a7d05d81b5) suggest to move to canvas for better display performance (this is what is tested in this page).

SVG is still used on the [tags](/tags) page.
- [SVG code]( https://jsfiddle.net/y_duf/r3dup56f/6/ ) - [ https://jsfiddle.net/y_duf/r3dup56f/6/ ]( https://jsfiddle.net/y_duf/r3dup56f/6/ )


## Better rendering

Things to explore
- ❌ Layering node & label by their depth in graph relative to current selection
- use community detection (?) - I think we loose purpose except if we can do it dynamically
- ✅ size node relative to tags usage  
- ❌ have distance to node be dependant on the relative count of their dependancies 
- ✅ Use Canvas  
	- ❌ Canvas is blurry when zooming 
    - ❌ dragging a node doesn't work


## Canvas direct rendering

<script src="https://d3js.org/d3.v7.min.js"></script>
<script id="example-script">
    const width =  400;
    const height = 400;
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");

    canvas.width = width;
    canvas.height = height;

    // Generate a large random graph (example)
    const NODES_COUNT = 1000;
    const nodes = d3.range(NODES_COUNT).map(i => ({ id: i }));
    const links = d3.range(NODES_COUNT * 2).map(() => ({
        source: Math.floor(Math.random() * NODES_COUNT),
        target: Math.floor(Math.random() * NODES_COUNT),
    }));

// Create a force simulation
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).distance(30))
    .force("charge", d3.forceManyBody().strength(-50))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", draw);

let transform = d3.zoomIdentity;
let selectedNode = null;

const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .on("zoom", (event) => {
        transform = event.transform;
        draw();
    });

d3.select(canvas).call(zoom);

function draw() {
    context.clearRect(0, 0, width, height);
    context.save();
    context.translate(transform.x, transform.y);
    context.scale(transform.k, transform.k);

    context.strokeStyle = "rgba(200,200,200,0.5)";
    links.forEach(d => {
        context.beginPath();
        context.moveTo(d.source.x, d.source.y);
        context.lineTo(d.target.x, d.target.y);
        context.stroke();
    });

    nodes.forEach(d => {
        context.beginPath();
        context.arc(d.x, d.y, 5, 0, 2 * Math.PI);
        context.fillStyle = d === selectedNode ? "red" : "steelblue";
        context.fill();
        context.stroke();
    });
    context.restore();
}

canvas.addEventListener("click", (event) => {
    const [x, y] = transform.invert([event.offsetX, event.offsetY]);
    selectedNode = nodes.find(d => Math.hypot(d.x - x, d.y - y) < 5) || null;
    draw();
});

const drag = d3.drag()
    .subject((event) => {
        const [x, y] = transform.invert([event.x, event.y]);
        return selectedNode || nodes.find(d => Math.hypot(d.x - x, d.y - y) < 5);
    })
    .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = event.x;
        d.fy = event.y;
    })
    .on("drag", (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
    })
    .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    });

d3.select(canvas).call(drag);
</script>


### Example JavaScript
    
<!-- Prism.js Styles -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>


<pre><code id="code-block"  class="language-javascript"></code></pre>
    
<script> // Fetch the script's content directly from the page and display it
    // Get the script content
    const codeBlock = document.getElementById('code-block');
    const scriptContent = document.getElementById('example-script').textContent.trim();

    // Set text content
    codeBlock.textContent = scriptContent;

    // Re-highlight using Prism.js
    Prism.highlightElement(codeBlock);
</script>

### References
