---
title: "Displaying Interactive Graph \U0001F6A7"
published: true
tags: d3.js graph jekyll tags yduf in-progress
---
> Efficient and usable graph display with 1'000 Nodes. A story about [tags](/tags) visualisation.

<div style="overflow: auto; width: 100%; max-height: 400px;">
  <canvas width="400" height="400"></canvas>
</div>

## Context

This my [Bookmarks / blog](/about), to organize thing, historically I was relying only on post title to search content back, then I used the most simplest form of [jekyll tags](({% post_url 2017-10-26-jekyll-tag-cloud %})) (without using any plugins) so it can still be hosted on github.

Here I am exploring how/if I can make sense of all this tags accumulated all these years, and see the relationship between them. At least that how it started.

### [d3-force](https://d3js.org/d3-force)

This d3 module implements an auto-layout model for displaying complex graph. It's what I choose to use as a starter for the tag graph (didn't consider other tool).

[ChatGPT](https://chatgpt.com/share/67d4209c-94f0-800d-9cb2-b38c22a052e7) was able to quicly write down a working solution, which I manage to fit with my jekyll constraint.

Some notes, on how this work.

d3-force([^1]) provide the simulation layout that apply the force on nodes([^2]). But the user is still responsible to display the elements, so we have flexibility to hide or show node as well as in which order or style we display them.

[^1]: [Force-directed graph component](https://observablehq.com/@d3/force-directed-graph-component)
[^2]: [Disjoint force-directed graph](https://observablehq.com/@d3/disjoint-force-directed-graph/2)

## Improved Display

Because of the number of nodes (~1'000) and dense relation between them (which was a surpise), the tool has a hardtime making things stand out.

So additionnal work is needed
- to make the page more responsive
- to make it more usable

This is what we explore below.

### The [tags](/tags) page

Is quite big (3.25MB), it contains
- the html text of tags
- the list of node (tags) and their relation (link between tag) in javascript form.

All generated by jekyll liquid templating.
As the information is duplicated several time, the size could probably reduced a lot:
- node/tag information is contains in the dom, and could be derived from there.
- links can be stored in js and injected in dom if we want to (see _related tag_ unfold field).

### Performance

I started using _svg_ as any example suggest, but [ChatGPT](https://chatgpt.com/share/67d6c69e-3bf0-800d-bbb6-28a7d05d81b5) suggest to move to canvas for better performance.

### Better rendering

Things to explore
- ❌ Layering node & label by their depth in graph relative to current selection
- use community detection (?) - I think we loose purpose except if we can do it dynamically
- ✅ size node relative to tags usage  
- ❌ have distance to node be dependant on the relative count of their dependancies 
- ✅ Use Canvas  
	- ❌ Canvas is blurry when zooming 
    - ❌ dragging a node doesn't work

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    const width =  400;
    const height = 400;
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");

    canvas.width = width;
    canvas.height = height;

    // Generate a large random graph (example)
    const NODES_COUNT = 1000;
    const nodes = d3.range(NODES_COUNT).map(i => ({ id: i }));
    const links = d3.range(NODES_COUNT * 2).map(() => ({
        source: Math.floor(Math.random() * NODES_COUNT),
        target: Math.floor(Math.random() * NODES_COUNT),
    }));

// Create a force simulation
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).distance(30))
    .force("charge", d3.forceManyBody().strength(-50))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", draw);

let transform = d3.zoomIdentity;
let selectedNode = null;

const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .on("zoom", (event) => {
        transform = event.transform;
        draw();
    });

d3.select(canvas).call(zoom);

function draw() {
    context.clearRect(0, 0, width, height);
    context.save();
    context.translate(transform.x, transform.y);
    context.scale(transform.k, transform.k);

    context.strokeStyle = "rgba(200,200,200,0.5)";
    links.forEach(d => {
        context.beginPath();
        context.moveTo(d.source.x, d.source.y);
        context.lineTo(d.target.x, d.target.y);
        context.stroke();
    });

    nodes.forEach(d => {
        context.beginPath();
        context.arc(d.x, d.y, 5, 0, 2 * Math.PI);
        context.fillStyle = d === selectedNode ? "red" : "steelblue";
        context.fill();
        context.stroke();
    });
    context.restore();
}

canvas.addEventListener("click", (event) => {
    const [x, y] = transform.invert([event.offsetX, event.offsetY]);
    selectedNode = nodes.find(d => Math.hypot(d.x - x, d.y - y) < 5) || null;
    draw();
});

const drag = d3.drag()
    .subject((event) => {
        const [x, y] = transform.invert([event.x, event.y]);
        return selectedNode || nodes.find(d => Math.hypot(d.x - x, d.y - y) < 5);
    })
    .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = event.x;
        d.fy = event.y;
    })
    .on("drag", (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
    })
    .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    });

d3.select(canvas).call(drag);


</script>

### References

