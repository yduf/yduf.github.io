---
published: true
tags: rust lang
title: Rust (lang)
toc: true
---
> beautiful code isn't enough, it has to be safe, beautiful, maintainable, productive, understandable, and resource efficient...  
> Rust hits more of these but it's ugly. Uglier than Python and approaches C++-level eyebleed. Rust generics aren't as flexible as they could be because type constraints don't have union and specialization is painful. Tag structs are laborious. Go hits more of these except it's not as flexible and not quite as safe as Rust. Rust makes enormous binaries and compiles slow and the cargo index download is glacial, I'm surprised they don't have an "sccache" for it. Go is easy to learn but then the capability of it plateaus. Go compiles and tests insanely fast. - [HN](https://news.ycombinator.com/item?id=34542798)

- The Rust Programming Language - [book](https://doc.rust-lang.org/stable/book/title-page.html)

## [About safety]({% post_url 2025-08-10-lang-memory-safety %})
- [	Eliminating Memory Safety Vulnerabilities at the Source](https://news.ycombinator.com/item?id=41650647) -  the benefits of re-writing the world are limited in terms of security. 

## Rust vs C/C++
- [Rust inadequate for text compression codecs?](https://palaiologos.rocks/posts/rust-codecs/) / [HN](https://news.ycombinator.com/item?id=43295908) - rust protections static vs dynamics
    - Codecs have next to no business logic moving parts. Most of it is the low-level nitty-gritty, which Rust is not particularly good at.
    - Bounds checks are rarely performed in the compiletime and we have to pay their price at the runtime. This is a significant performance hit for codecs.
    - The ownership model is not particularly useful to codecs. It is usually painfully clear who owns what (it’s usually the “god structure” of the codec owning everything else) and for how long (between calls to bz3_new and bz3_free).
    - Rust is much more ergonomic for the typical workload than C or C++, but a fundamentally unobtrusive language is more conducive to implementing low-level performance-sensitive code.

- [Why I rewrote the mesh generator of Dust3D from Rust to C++](https://news.ycombinator.com/item?id=19376939) - When you implement an algorithm using C++, you can write it down without one second of pause, but you can’t do that in Rust.
	- The issue is that code that the borrow checker flags is not code that is unsafe, but code that the borrow checker cannot prove safe. There is a difference.
Until, you natively start thinking and writing code with idioms that the borrow checker is tuned for, there will be friction. 

## [Interoperability](https://chatgpt.com/share/68a09264-a254-800d-a613-6e81838c2345)

- [Integrating Rust into Existing C/C++ Projects](https://medium.com/@AlexanderObregon/integrating-rust-into-existing-c-c-projects-e0810dbddded)
- [Rust C++ Interop: Bridging Two Powerful Languages](https://cppscripts.com/rust-cpp-interop)
- [CXX — safe interop between Rust and C++](https://cxx.rs/) - This library provides a safe mechanism for calling C++ code from Rust and Rust code from C++.

*Numbers are compiled from community benchmarks and JNI/PyO3 microbenchmarks on modern CPUs; they vary depending on CPU speed, OS, and argument complexity.

| Language Pair     | Typical Interop Method  | Approx. Per-call Overhead\*                                                                            | Meaning in Context                                                                                       |
| ----------------- | ----------------------- | ------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------- |
| **Rust ↔ C**      | FFI (C ABI)             | **< 50 ns** (nanoseconds)                                                                              | Effectively negligible; like a direct C function call. You could make millions of calls per millisecond. |
| **Rust ↔ C++**    | FFI (C ABI, extern "C") | **< 50–100 ns**                                                                                        | Essentially the same as C; most “overhead” comes from type conversions if needed, not the call.          |
| **Rust ↔ Java**   | JNI                     | **1–3 µs** (microseconds) per call for primitive args; **5–10 µs** or more for object/string arguments | 20–200× slower than a native function call; frequent calls can dominate runtime.                         |
| **Rust ↔ Python** | PyO3 / cffi / ctypes    | **\~3–10 µs** per call (PyO3); ctypes can be **10–50 µs**                                              | This is 60–1000× slower than in-language calls; batching work is critical.                               |
| **Rust ↔ Ruby**   | ruru / native extension | **\~5–15 µs** per call                                                                                 | Similar to Python; acceptable for coarse-grained calls, expensive for fine-grained loops.                |


### see also
- [Leaving Rust gamedev after 3 years ](https://loglog.games/blog/leaving-rust-gamedev/) / [HN](https://news.ycombinator.com/item?id=40172033) - _The problem you're having is only a problem because you haven't tried hard enough._

- [Was Rust Worth It? ](https://news.ycombinator.com/item?id=38019231) - mixed feelling
- [Rust: A Scala Engineer's Perspective](https://beachape.com/blog/2017/05/24/rust-from-scala/)
- [	A practical comparison of build and test speed between C++ and Rust](https://news.ycombinator.com/item?id=34271293)
- [Why I think C++ is still a desirable coding platform compared to Rust](https://lucisqr.substack.com/p/why-i-think-c-is-still-a-very-attractive) / [review from a rust fan](https://www.youtube.com/watch?v=Wz0H8HFkI9U) / [HN](https://news.ycombinator.com/item?id=38378874)
