---
published: true
title: Go (lang)
tags: lang simplicity complexity graph compiler
---
>  a language that makes it quite easy for enterprises to deal with developers as cogs. – [HN](https://news.ycombinator.com/item?id=16143918)

## [Overview](https://talks.golang.org/2016/applicative.slide#1)

> GO syntax is very regressive comparing to where we hopped programming languages should go.
I believe GO success is partly because in recent years, we have many new specialized engineers that programming isn’t their main focus (DevOps, Data Scientists, SREs) and naturally they are looking for tooling with shorter learning curve. - [HN](https://news.ycombinator.com/item?id=21223242)

> ... **Both of these decisions**, in major modern languages, solve certain classes of problems—and both **pay a price for their choices.** Go’s error handling has become a meme, for example. Articles to help with understanding lifetimes in Rust are nearly as ubiquitous as monad tutorials for the aspiring Haskeller, and it turns out that a lot of important data structures are pretty hard to implement when you have to worry about them. Still, you can’t say that either language has failed in its goals—it’s just that each has chosen different tradeoffs. **In other words: every decision made in order to simplify a program will cost something.** - [The Danger of “Simplicity”](https://asthasr.github.io/posts/danger-of-simplicity/) - [HN](https://news.ycombinator.com/item?id=21604710)
- [Why Go’s design is a disservice to intelligent programmers](http://nomad.uk.net/articles/why-gos-design-is-a-disservice-to-intelligent-programmers.html)
    
    
- [Go’s Features of Last Resort](https://news.ycombinator.com/item?id=21603483)
- [Using Graphs to Search for Code](https://nickgregory.me/post/2022/07/02/go-code-as-a-graph/) - Passing &data instead of just data caused binary.Read to take nearly twice as long, and the function this was in was responsible for the vast majority of the request runtime.
