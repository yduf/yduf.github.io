---
published: true
title: Zig
tags: lang zig c++ rust golang
---
> The reason why we can often get away with using languages like Python or JavaScript to drive resource-intensive computations, is because under the hood somebody took years to perfect a C implementation of a key procedure and shared it with the world under a permissive license. - [Maintain it With Zig](https://kristoff.it/blog/maintain-it-with-zig/) / [HN](https://news.ycombinator.com/item?id=28458713) / [Home](https://ziglang.org/)

<link rel="shortcut icon" href="https://ziglang.org/favicon.svg" type="image/svg+xml" />

see also
- [Zig Toolchain](https://chatgpt.com/share/67ff49b0-cec4-800d-8904-56ee3ca04725) - Zig has its own build system, You define builds with Zig code.
- [	Carbon Language: An experimental successor to C++ ](https://news.ycombinator.com/item?id=44745984) - arbon exists so that it's possible to migrate a large C++ code base, like Chrome, from C++ to something saner, incrementally.
  - Zig is designed to interoperate like this with C, and Kotlin with Java. - [HN](https://news.ycombinator.com/item?id=44750232)

- [My game development journey & why I'm increasing my contribution to Zig to $200/mo](https://devlog.hexops.com/2021/increasing-my-contribution-to-zig-to-200-a-month/)
- [What's Zig got that C, Rust and Go don't have? (with Loris Cro)](https://www.youtube.com/watch?v=5_oqWE9otaE)
	- _rust_ add complexity & prefer safety over performance
    - _go_ toward simplicity, but not in minimalistic way (different way of seeing things). Can reuse C, but not be consumed by C.
    - _zig_ allow low system programming
		- on linux call syscall directly (no need fot clib)
- [From Go to Zig](https://c7.se/from-go-to-zig/)
- [Why Zig When There is Already C++, D, and Rust?](https://ziglang.org/learn/why_zig_rust_d_cpp/)


### [Zig Interop Overhead Table with Metrics](https://chatgpt.com/share/689cc4f9-5050-800d-a14e-79307fbbcfd6)

These are rough per-function call latencies on modern desktop CPUs. Actual values vary based on OS, CPU, type conversion, and data size.

| Language    | Interop Method       | Typical Workflow                                 | Overhead Level | Approx. Call Latency\*                       |
| ----------- | -------------------- | ------------------------------------------------ | -------------- | -------------------------------------------- |
| **Java**    | JNI                  | Zig shared lib loaded via `System.loadLibrary()` | Low            | **\~50–200 ns** per native call              |
|             | JNA/JNR              | Reflection-based FFI                             | Medium         | **\~1–5 µs** per call                        |
|             | IPC (sockets, REST)  | Zig as separate process                          | High           | **\~100 µs – 1 ms** per request              |
| **C++**     | C ABI wrappers       | `extern "C"`                                     | Low            | **\~5–50 ns** per call                       |
|             | Direct C++ interop   | `@cImport` + C++                                 | Medium         | **\~50–200 ns** (depends on ABI, exceptions) |
| **Ruby**    | C extension          | Zig lib loaded as native Ruby extension          | Low            | **\~50–200 ns** per call                     |
|             | Ruby FFI (`ffi` gem) | Zig C ABI lib via FFI                            | Medium         | **\~1–5 µs** per call                        |
| **Python**  | CPython C API        | Zig compiled as Python module                    | Low            | **\~50–200 ns** per call                     |
|             | `ctypes`/`cffi`      | Zig C ABI lib loaded in Python                   | Medium         | **\~1–10 µs** per call                       |
| **General** | IPC                  | Sockets/pipes/gRPC                               | High           | **\~100 µs – 1+ ms** per round-trip          |
