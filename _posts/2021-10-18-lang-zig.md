---
published: true
title: Zig
tags: lang zig c++ rust golang
---
> The reason why we can often get away with using languages like Python or JavaScript to drive resource-intensive computations, is because under the hood somebody took years to perfect a C implementation of a key procedure and shared it with the world under a permissive license. - [Maintain it With Zig](https://kristoff.it/blog/maintain-it-with-zig/) / [HN](https://news.ycombinator.com/item?id=28458713) / [Home](https://ziglang.org/)

<link rel="shortcut icon" href="https://ziglang.org/favicon.svg" type="image/svg+xml" />

**main.zig**
{% highlight zig %}
const std = @import("std");

pub fn main() void {
    std.debug.print("Hello, Zig!\n", .{});
}
{% endhighlight %}

Then to run
- work from scracth with vscode .runner
- `zig run main.zig` - compile & run
- `zig build-exe main.zig` - materialize binary
	-  `./main` - to execute

# [Install](https://chatgpt.com/share/69749aeb-8dc0-800d-8bb7-e5b4c810a9b8)

As of now, Zig is generally not included in the official Debian repos.
The easiest way seems to use [Hombrew]({% post_url 2026-01-24-package-homebrew %}) or [Nix]({% post_url 2026-01-24-package-nix %}) (prefered for linux)

## [Nix Install](https://chatgpt.com/share/6974d688-4890-800d-b862-c5c8c0c596d7)

Using profile

{% highlight bash %}
$ nix profile add nixpkgs#zig
{% endhighlight %}

# C++ interop
- [Zig / C++ Interop ](https://tuple.app/blog/zig-cpp-interop)

see also
- [Opinion piece: On Zig (and the design choices within) ](https://blueberrywren.dev/blog/on-zig/) / [HN](https://news.ycombinator.com/item?id=45876990)
- [62 chapter open-source Zig book](https://news.ycombinator.com/item?id=45947810) - **(flagged) I submitted this and unfortunately it is likely AI generated.**
- [Zig Toolchain](https://chatgpt.com/share/67ff49b0-cec4-800d-8904-56ee3ca04725) - Zig has its own build system, You define builds with Zig code.
- [	Carbon Language: An experimental successor to C++ ](https://news.ycombinator.com/item?id=44745984) - arbon exists so that it's possible to migrate a large C++ code base, like Chrome, from C++ to something saner, incrementally.
  - Zig is designed to interoperate like this with C, and Kotlin with Java. - [HN](https://news.ycombinator.com/item?id=44750232)

- [My game development journey & why I'm increasing my contribution to Zig to $200/mo](https://devlog.hexops.com/2021/increasing-my-contribution-to-zig-to-200-a-month/)
- [What's Zig got that C, Rust and Go don't have? (with Loris Cro)](https://www.youtube.com/watch?v=5_oqWE9otaE)
	- _rust_ add complexity & prefer safety over performance
    - _go_ toward simplicity, but not in minimalistic way (different way of seeing things). Can reuse C, but not be consumed by C.
    - _zig_ allow low system programming
		- on linux call syscall directly (no need fot clib)
- [From Go to Zig](https://c7.se/from-go-to-zig/)
- [Why Zig When There is Already C++, D, and Rust?](https://ziglang.org/learn/why_zig_rust_d_cpp/)
- [	Zig feels more practical than Rust for real-world CLI tools](https://news.ycombinator.com/item?id=45346387)

## [Zig Interop Overhead Table with Metrics](https://chatgpt.com/share/689cc4f9-5050-800d-a14e-79307fbbcfd6)

These are rough per-function call latencies on modern desktop CPUs. Actual values vary based on OS, CPU, type conversion, and data size.

| Language    | Interop Method       | Typical Workflow                                 | Overhead Level | Approx. Call Latency\*                       |
| ----------- | -------------------- | ------------------------------------------------ | -------------- | -------------------------------------------- |
| **Java**    | JNI                  | Zig shared lib loaded via `System.loadLibrary()` | Low            | **\~50–200 ns** per native call              |
|             | JNA/JNR              | Reflection-based FFI                             | Medium         | **\~1–5 µs** per call                        |
|             | IPC (sockets, REST)  | Zig as separate process                          | High           | **\~100 µs – 1 ms** per request              |
| **C++**     | C ABI wrappers       | `extern "C"`                                     | Low            | **\~5–50 ns** per call                       |
|             | Direct C++ interop   | `@cImport` + C++                                 | Medium         | **\~50–200 ns** (depends on ABI, exceptions) |
| **Ruby**    | C extension          | Zig lib loaded as native Ruby extension          | Low            | **\~50–200 ns** per call                     |
|             | Ruby FFI (`ffi` gem) | Zig C ABI lib via FFI                            | Medium         | **\~1–5 µs** per call                        |
| **Python**  | CPython C API        | Zig compiled as Python module                    | Low            | **\~50–200 ns** per call                     |
|             | `ctypes`/`cffi`      | Zig C ABI lib loaded in Python                   | Medium         | **\~1–10 µs** per call                       |
| **General** | IPC                  | Sockets/pipes/gRPC                               | High           | **\~100 µs – 1+ ms** per round-trip          |
