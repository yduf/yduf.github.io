---
published: true
title: AVX Mask
tags: c++ avx
---
> There is no single instruction in AVX2 or earlier. (AVX512 can use masks in bitmap form directly, and has an instruction to expand masks to vectors). - [Peter Cordes (SO)](https://stackoverflow.com/a/36491672/51386)

- [Is AVX intrinsic _mm256_cmp_ps supposed to return NaN when true?](https://stackoverflow.com/questions/37099874/is-avx-intrinsic-mm256-cmp-ps-supposed-to-return-nan-when-true) 

The result is all 1s, for true, which happens to be a NaN. For false it's all 0s, which happens to be 0.0. Typically you use the result as a bitwise mask, so the float value isn't really meaningful.


### _mm256_movemask_ps  (mm256 -> int)

{% highlight cpp %}
int as_int( const v8f& f) { 
	return _mm256_movemask_ps( f.v); 
}
{% endhighlight %}

### [reversing _mm256_movemask_ps](https://stackoverflow.com/a/36491672/51386)

- [is there an inverse instruction to the movemask instruction in intel avx2?](https://stackoverflow.com/questions/36488675/is-there-an-inverse-instruction-to-the-movemask-instruction-in-intel-avx2)
	- [How to use bits in a byte to set dwords in ymm register without AVX2? (Inverse of vmovmskps)](https://stackoverflow.com/questions/48811369/how-to-use-bits-in-a-byte-to-set-dwords-in-ymm-register-without-avx2-inverse-o)
    
{% highlight cpp %}
al = 0110 0001

ymm0 = 0x00000000 FFFFFFFF FFFFFFFF 00000000 00000000 00000000 00000000 FFFFFFFF
{% endhighlight %}

4 bits -> 4 qwords in a YMM register: this answer: a LUT is good, ALU also good  
8 bits -> 8 dwords in a YMM register: this answer (or this without AVX2). ALU.


	
- [How to perform the inverse of _mm256_movemask_epi8 (VPMOVMSKB)?](https://stackoverflow.com/questions/21622212/how-to-perform-the-inverse-of-mm256-movemask-epi8-vpmovmskb)

{% highlight cpp %}
int mask = _mm256_movemask_epi8(__m256i s1);
// vs
__m256i get_mask2(const uint32_t mask)
{% endhighlight %}


